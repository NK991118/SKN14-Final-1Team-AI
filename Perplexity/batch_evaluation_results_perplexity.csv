index,question,reference,system_answer,accuracy,recall,specificity
0,Analytics Hub 게시자와 목록 관리자 역할의 차이점은 무엇인가요?,"Analytics Hub 게시자 역할은 목록을 생성, 업데이트, 삭제하고 목록에 IAM 정책을 설정할 수 있습니다. 반면, Analytics Hub 목록 관리자 역할은 목록을 업데이트 및 삭제하고 목록에 IAM 정책을 설정할 수 있지만, 목록을 생성하는 권한은 없습니다. 즉, 게시자는 목록 생성 권한이 추가로 부여된다는 점이 주요 차이점입니다.","**Analytics Hub 게시자 역할**은 목록을 생성, 업데이트, 삭제하고 목록에 대한 IAM 정책을 설정할 수 있는 권한을 가진 역할입니다. 즉, 게시자는 데이터 교환 내에서 새로운 목록을 만들고, 기존 목록을 관리하며, 목록에 대한 접근 권한을 제어할 수 있습니다[1][2].

반면, **Analytics Hub 목록 관리자 역할**은 목록을 업데이트 및 삭제하고 목록에 IAM 정책을 설정할 수 있지만, 목록 생성 권한은 포함하지 않습니다. 목록 관리자는 주로 기존 목록의 관리와 권한 설정에 집중하는 역할입니다[1].

요약하면 다음과 같습니다:

| 역할           | 주요 권한                                   |
|----------------|--------------------------------------------|
| 게시자         | 목록 생성, 업데이트, 삭제, IAM 정책 설정  |
| 목록 관리자    | 목록 업데이트, 삭제, IAM 정책 설정         |

게시자는 목록을 새로 만들 수 있는 권한이 추가로 있으며, 목록 관리자는 생성 권한 없이 기존 목록 관리에 집중합니다[1][2].",100,100,100
1,BigQuery Studio 저장된 쿼리에 공개 액세스 권한을 방지하려면 어떻게 해야 하나요?,"BigQuery Studio 저장된 쿼리에 공개 액세스 권한을 방지하려면 프로젝트에서 allAuthenticatedUsers 주 구성원을 제한해야 합니다. 이를 위해 iam.allowedPolicyMemberDomains 정책을 설정하고 allowed_values 목록에서 allAuthenticatedUsers를 삭제하면 됩니다. 이 정책을 적용하면 프로젝트의 모든 IAM 정책에서 allAuthenticatedUsers 주 구성원을 사용할 수 없으므로, BigQuery Studio 저장된 쿼리를 비롯한 모든 리소스에 대한 공개 액세스 권한이 부여되지 않습니다.","BigQuery Studio에서 저장된 쿼리에 공개 액세스 권한을 방지하려면 다음 단계를 따르세요:

1. **프로젝트에서 allAuthenticatedUsers 제한**:
   - 저장된 쿼리에 공개 액세스 권한이 부여되지 않도록 하려면 프로젝트에서 `allAuthenticatedUsers` 주 구성원을 제한해야 합니다. 이는 모든 인증된 사용자가 자동으로 권한을 받는 것을 방지합니다.

2. **IAM을 통한 권한 관리**:
   - Google Cloud Console에서 IAM을 사용하여 저장된 쿼리에 대한 액세스를 제어합니다. 특정 사용자나 그룹에게만 필요한 권한을 부여하여 보안을 강화할 수 있습니다[2][5].

3. **최소 권한 원칙 적용**:
   - 클라우드 최소 권한(Cloud Least Privilege) 원칙에 따라, 사용자에게 필요한 시점에 필요한 최소한의 권한만 부여합니다. 이는 보안 위험을 줄이는 데 도움이 됩니다[1][3].

4. **정기적인 모니터링**:
   - 사용자 활동과 권한을 정기적으로 모니터링하여 불필요한 권한이 부여되지 않도록 합니다[3]. 

이러한 방법을 통해 저장된 쿼리에 대한 공개 액세스를 방지하고, 보안을 강화할 수 있습니다.",70,80,70
2,calendarId에 primary 키워드를 사용하면 어떤 캘린더에 접근할 수 있나요?,calendarId에 primary 키워드를 사용하면 현재 로그인한 사용자의 기본 캘린더에 접근할 수 있습니다.,"calendarId에 **""primary""** 키워드를 사용하면, 인증된 사용자의 **기본 캘린더**에 접근할 수 있습니다. 즉, 로그인한 사용자의 주 캘린더를 가리키는 특수한 식별자입니다[1][2][3].

- Google Calendar API에서 calendarId에 ""primary""를 넣으면, 해당 사용자의 기본 캘린더 메타데이터나 이벤트를 조회, 생성, 수정할 수 있습니다.
- 별도의 캘린더 ID를 알 필요 없이 ""primary""만으로 기본 캘린더를 지정할 수 있어 편리합니다.
- 이 기능은 인증된 사용자 컨텍스트에서만 동작하며, 적절한 OAuth 권한 범위가 필요합니다[2].

따라서 ""primary""는 구글 계정에 연결된 기본 캘린더를 의미하는 예약어로 사용됩니다.",95,95,90
3,Google Drive API v3의 서비스 엔드포인트가 궁금해,Google Drive API v3의 서비스 엔드포인트는 https://www.googleapis.com 입니다.,"## Google Drive API v3 서비스 엔드포인트

Google Drive API v3의 **기본 서비스 엔드포인트**는 다음과 같습니다.

```
https://www.googleapis.com/drive/v3
```
이 엔드포인트는 모든 Google Drive API v3 요청의 기준 URL로 사용됩니다[1]. 예를 들어, 파일 목록을 조회하려면 `https://www.googleapis.com/drive/v3/files`와 같이 엔드포인트 뒤에 리소스 경로를 붙여 요청합니다[4].

## 주요 특징

- **REST 기반**: Google Drive API v3는 HTTP/JSON 기반의 REST API로 제공되며, 다양한 프로그래밍 언어용 클라이언트 라이브러리도 지원합니다[1][5].
- **리소스 경로**: 엔드포인트 뒤에 `/files`, `/permissions`, `/comments` 등 구체적인 리소스 경로를 추가해 각 기능을 사용할 수 있습니다[1].
- **인증 필요**: 모든 API 호출에는 OAuth 2.0 등 적절한 인증이 필요합니다[5].
- **Private Service Connect**: Google Cloud 환경에서는 Private Service Connect를 통해 비공개 엔드포인트를 구성할 수도 있지만, 일반적으로는 위의 공개 엔드포인트를 사용합니다[3].

## 예시: 파일 생성 요청

새 파일을 생성할 때는 다음과 같이 엔드포인트를 사용합니다.

```
POST https://www.googleapis.com/drive/v3/files
```
요청 본문에 파일명, 설명 등 필요한 정보를 포함해 전송하면, 응답으로 파일의 메타데이터(파일 ID, 이름 등)를 받을 수 있습니다[4].

## 요약

Google Drive API v3의 공식 서비스 엔드포인트는 `https://www.googleapis.com/drive/v3`이며, 이 URL을 기준으로 각종 리소스에 대한 REST 요청을 보낼 수 있습니다[1][4]. 인증이 필요하며, 클라이언트 라이브러리 사용을 권장합니다[1][5].",90,95,90
4,files.create 메서드의 최대 파일 크기와 허용되는 미디어 MIME 유형은 무엇인가요? ,"files.create 메서드의 최대 파일 크기는 5,120GB입니다. 허용되는 미디어 MIME 유형은 */*로, 이는 모든 유효한 MIME 유형을 업로드할 수 있음을 의미합니다. 단, 실제로는 리터럴 */* 대신 유효한 MIME 유형을 지정해야 합니다.","Google Drive API의 `files.create` 메서드에서 **최대 파일 크기는 5,120GB**이며, **허용되는 미디어 MIME 유형은 모든 유형(`*/*`)**입니다. 다만, `*/*`는 모든 MIME 유형을 허용한다는 의미의 리터럴 값으로, 실제로는 유효한 MIME 유형을 지정해야 합니다[1].

즉, 업로드 시 MIME 유형을 구체적으로 지정해야 하며, 예를 들어 JPEG 파일은 `""name"": ""cat.jpg""`와 같이 파일 확장자를 메타데이터에 포함시켜야 합니다. Google Drive는 확장자가 없으면 MIME 유형을 기반으로 확장자를 결정하려고 시도합니다[1].

요약하면:

| 항목           | 내용                          |
|----------------|-------------------------------|
| 최대 파일 크기 | 5,120GB                      |
| 허용 MIME 유형 | 모든 유형(`*/*`), 단 실제 MIME 유형 지정 필요 |

이 외에 MIME 유형 예시는 Google Workspace 관리자 문서에서 `image/`, `video/`, `audio/`, `text/`, `application/` 등 다양한 유형이 일반적으로 사용됨을 참고할 수 있습니다[4]. 하지만 `files.create` 메서드 자체는 MIME 유형 제한 없이 모든 유형을 지원합니다[1].",95,95,90
5,Firebase scrypt 해시 비밀번호를 사용한 사용자 가져오는 방법은?,"Firebase scrypt 해시 비밀번호를 사용한 사용자를 가져오려면, 먼저 Firebase 콘솔의 사용자 탭에서 비밀번호 해시 매개변수를 확인해야 합니다. 그런 다음, 해당 매개변수(key, saltSeparator, rounds, memoryCost)를 사용하여 scrypt 해시 옵션을 구성하고, 사용자의 password_hash와 password_salt를 base64로 디코딩하여 ImportUserRecord에 입력합니다. 마지막으로, auth.import_users 함수를 사용해 사용자를 가져올 수 있습니다. 예시 코드는 아래와 같습니다.

```Python
users = [
    auth.ImportUserRecord(
        uid='some-uid',
        email='user@example.com',
        password_hash=base64.urlsafe_b64decode('password_hash'),
        password_salt=base64.urlsafe_b64decode('salt')
    ),
]

# All the parameters below can be obtained from the Firebase Console's ""Users""
# section. Base64 encoded parameters must be decoded into raw bytes.
hash_alg = auth.UserImportHash.scrypt(
    key=base64.b64decode('base64_secret'),
    salt_separator=base64.b64decode('base64_salt_separator'),
    rounds=8,
    memory_cost=14
)
try:
    result = auth.import_users(users, hash_alg=hash_alg)
    for err in result.errors:
        print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
    print('Error importing users:', error)
```
이 과정을 통해 기존 Firebase 프로젝트에서 scrypt 해시 비밀번호를 사용한 사용자를 새로운 프로젝트로 마이그레이션할 수 있습니다.","## Firebase scrypt 해시 비밀번호로 사용자 가져오기

Firebase Admin SDK의 **Auth.importUsers()** API를 사용하면, 기존에 scrypt 해시로 저장된 비밀번호를 가진 사용자를 Firebase Authentication에 일괄적으로 가져올 수 있습니다[1]. 이 기능은 기존 시스템에서 Firebase로 사용자 마이그레이션 시 유용합니다.

### 사전 준비

- **Firebase 프로젝트의 scrypt 해시 매개변수 확인**:  
  Firebase는 각 프로젝트마다 고유의 scrypt 해시 매개변수를 사용합니다.  
  Firebase 콘솔의 **사용자** 탭 → 오른쪽 상단 드롭다운에서 **비밀번호 해시 매개변수**를 선택하면, 아래와 같은 매개변수를 확인할 수 있습니다[1].
  - **key**: base64로 인코딩된 서명자 키
  - **saltSeparator**: base64로 인코딩된 솔트 구분자 (선택사항)
  - **rounds**: 해시 라운드 수
  - **memoryCost**: 메모리 비용

### 사용자 데이터 준비

- **사용자 정보**: 각 사용자마다 uid, email, passwordHash(바이트 버퍼), passwordSalt(바이트 버퍼) 등 필수 정보를 준비합니다.
- **해시 알고리즘 지정**: importUsers() 호출 시 hash 옵션에서 algorithm을 **SCRYPT**로 지정하고, 위에서 확인한 매개변수를 함께 전달합니다.

### 예시 (Node.js)

```js
const admin = require('firebase-admin');
admin.initializeApp();

const users = [
  {
    uid: 'user1',
    email: 'user1@example.com',
    passwordHash: Buffer.from('...'), // 원본 scrypt 해시값 (바이트 버퍼)
    passwordSalt: Buffer.from('...'), // 원본 솔트 (바이트 버퍼)
  },
  // 추가 사용자...
];

const options = {
  hash: {
    algorithm: 'SCRYPT',
    // Firebase 콘솔에서 확인한 값 입력
    key: Buffer.from('base64로_인코딩된_key', 'base64'),
    saltSeparator: Buffer.from('base64로_인코딩된_saltSeparator', 'base64'),
    rounds: 8, // 실제 값 입력
    memoryCost: 14, // 실제 값 입력
  },
};

admin.auth().importUsers(users, options)
  .then((result) => {
    console.log('성공:', result);
  })
  .catch((error) => {
    console.error('실패:', error);
  });
```
- **passwordHash**와 **passwordSalt**는 반드시 원본 데이터베이스에서 추출한 값을 그대로 사용해야 하며, Firebase의 해시 매개변수와 일치해야 정상적으로 로그인이 가능합니다[1].
- **rounds**와 **memoryCost**도 반드시 원본 시스템과 동일하게 설정해야 합니다.

### 주의사항

- **Firebase의 scrypt는 표준 scrypt와 다름**: Firebase는 표준 scrypt 알고리즘을 수정해 사용하므로, 반드시 Firebase 콘솔에서 확인한 매개변수를 사용해야 합니다[1].
- **테스트 필수**: 소규모 사용자로 먼저 테스트하여 해시값이 정상적으로 동작하는지 확인하세요.
- **CLI 사용**: Firebase CLI의 auth:import 명령어로도 파일 기반 일괄 가져오기가 가능합니다[3].

### 요약

Firebase scrypt 해시 비밀번호로 사용자를 가져오려면,  
1. **원본 시스템의 해시값과 솔트를 추출**하고,  
2. **Firebase 콘솔에서 scrypt 해시 매개변수를 확인**한 뒤,  
3. **Admin SDK의 importUsers() API**에 맞는 형식으로 데이터를 변환해 전달하면 됩니다[1].  
이 과정에서 해시 매개변수 일치가 가장 중요합니다.",90,95,90
6,커스텀 인증 시스템으로 Firebase에 인증하려면 어떻게 해야 하나요?,"커스텀 인증 시스템으로 Firebase에 인증하려면, 먼저 인증 서버에서 사용자의 로그인 인증 정보를 확인한 후 커스텀 Firebase 토큰을 생성해야 합니다. 그런 다음, 앱에서 이 토큰을 받아 signInWithCustomToken() 메서드에 전달하여 사용자를 로그인 처리할 수 있습니다. 예시 코드는 아래와 같습니다.

```
try {
    final userCredential =
        await FirebaseAuth.instance.signInWithCustomToken(token);
    print(""Sign-in successful."");
} on FirebaseAuthException catch (e) {
    switch (e.code) {
        case ""invalid-custom-token"":
            print(""The supplied token is not a Firebase custom auth token."");
            break;
        case ""custom-token-mismatch"":
            print(""The supplied token is for a different Firebase project."");
            break;
        default:
            print(""Unknown error."");
    }
}
```
이 과정을 완료하면 사용자가 Firebase에 정상적으로 인증됩니다.","커스텀 인증 시스템으로 Firebase에 인증하려면, 사용자의 로그인 인증 정보를 자체 인증 서버로 전송하여 검증한 후, 서버에서 유효한 경우 Firebase용 커스텀 토큰을 생성해 앱에 반환하고, 앱에서는 이 토큰을 `signInWithCustomToken()` 메서드에 전달하여 Firebase에 로그인 처리합니다.

구체적인 절차는 다음과 같습니다:

1. **사용자 인증 정보 수집 및 서버 전송**  
   앱에서 사용자 이름, 비밀번호 등 로그인 정보를 수집하여 자체 인증 서버로 보냅니다[1][3].

2. **서버에서 사용자 인증 및 커스텀 토큰 생성**  
   인증 서버가 사용자 정보를 검증한 후, Firebase Admin SDK를 사용해 커스텀 JWT 토큰을 생성합니다. 이 토큰은 Firebase에서 사용자를 인증하는 데 필요한 정보를 포함합니다[1][3].

3. **앱에서 커스텀 토큰으로 Firebase 로그인**  
   앱은 서버로부터 받은 커스텀 토큰을 Firebase SDK의 `signInWithCustomToken()` 함수에 전달하여 Firebase 인증을 수행합니다. 예를 들어, 웹 버전 9에서는 다음과 같이 사용합니다[1]:

   ```javascript
   import { getAuth, signInWithCustomToken } from ""firebase/auth"";
   const auth = getAuth();
   signInWithCustomToken(auth, token)
     .then((userCredential) => {
       const user = userCredential.user;
       // 로그인 성공 처리
     })
     .catch((error) => {
       const errorCode = error.code;
       const errorMessage = error.message;
       // 에러 처리
     });
   ```

4. **Firebase Admin SDK 설정**  
   커스텀 토큰 생성을 위해 Firebase 프로젝트의 서비스 계정 비공개 키를 생성하고, 서버에 설정해야 합니다[3].

이 과정을 통해 Firebase 인증 시스템과 자체 인증 시스템을 연동할 수 있으며, 필요에 따라 커스텀 클레임을 추가하거나 REST API를 활용해 확장할 수 있습니다[1].

요약하면, **자체 인증 서버에서 Firebase용 커스텀 토큰을 발급받아 앱에서 `signInWithCustomToken()`으로 로그인하는 방식**입니다. 이 방법은 Firebase가 기본 제공하지 않는 인증 방식을 사용할 때 유용합니다.",90,95,90
7,"Firestore에서 맵 필드에 대한 단일 필드 색인 예외를 설정하면, 하위 필드들은 그 설정을 상속하나요?","네, Firestore에서 맵 필드에 단일 필드 색인 예외를 만들면 맵의 하위 필드들은 해당 설정을 상속합니다. 하지만 특정 하위 필드에 대해 별도로 단일 필드 색인 예외를 정의할 수도 있습니다.","Firestore에서 **맵 필드에 단일 필드 색인 예외를 설정하면, 그 설정이 맵의 하위 필드들에 상속**됩니다. 즉, 상위 맵 필드에 예외를 지정하면 기본적으로 그 하위 필드들도 동일한 예외 설정을 따릅니다. 다만, 특정 하위 필드에 대해 별도의 단일 필드 색인 예외를 정의할 수도 있으며, 이 경우 해당 하위 필드는 상위 필드의 예외 설정 대신 자신만의 예외 설정을 따릅니다[1].

추가로, 하위 필드의 예외를 삭제하면 그 하위 필드는 다시 상위 필드의 예외 설정(존재할 경우)이나 데이터베이스 전체의 기본 자동 색인 설정을 상속하게 됩니다[1]. 

따라서, 맵 필드 단위로 예외를 설정하면 편리하게 하위 필드 전체에 적용할 수 있지만, 필요에 따라 하위 필드별로 개별 예외를 지정하거나 해제할 수 있는 유연성도 제공합니다.",95,95,90
8,Firebase의 updateTime 필드에 사용되는 시간 형식이 뭐야?,"Firebase의 updateTime 필드에는 RFC 3339 시간 형식이 사용됩니다. 이 형식은 Z-normalized를 기본으로 하며, 0, 3, 6 또는 9자리 소수점까지 지원합니다. 또한 'Z' 이외의 오프셋도 허용됩니다.","## Firebase의 updateTime 필드 시간 형식

Firebase의 **updateTime** 필드(또는 Firestore에서 Timestamp로 저장되는 필드)는 **Timestamp** 객체로 저장됩니다. 이 객체는 내부적으로 **Unix epoch(1970년 1월 1일 00:00:00 UTC) 이후의 초(_seconds)**와 **나노초(_nanoseconds)**로 시간을 표현합니다[1][4].  
예를 들어, 다음과 같은 형태로 데이터가 저장됩니다.

```json
{
  ""updateTime"": {
    ""_seconds"": 1618381810,
    ""_nanoseconds"": 792000000
  }
}
```
이 값은 **직접적으로 날짜/시간 문자열이 아니며**, JavaScript, Java, Kotlin 등에서 `.toDate()` 메서드를 사용해 Date 객체로 변환해야 일반적인 날짜/시간 형식으로 사용할 수 있습니다[2][4].

## 변환 예시

- **JavaScript**:  
  ```js
  console.log(doc.data().updateTime.toDate());
  // 출력 예: 2021-04-14T06:30:10.792Z
  ```
- **Kotlin**:  
  ```kotlin
  val updateTime = (doc[""updateTime""] as Timestamp).toDate()
  ```
- **포맷 변환**:  
  변환된 Date 객체는 moment.js, day.js, SimpleDateFormat, DateTimeFormatter 등으로 원하는 형식(예: ""YYYY-MM-DD HH:mm"")으로 포맷할 수 있습니다[2][4].

## 요약

- **저장 형식**: Unix epoch 이후 초(_seconds)와 나노초(_nanoseconds)를 가진 Timestamp 객체[1][4].
- **사용 방법**: `.toDate()`로 Date 객체로 변환 후, 필요에 따라 포맷팅[2][4].
- **직접적인 날짜 문자열이 아님**: 콘솔에서 보이는 날짜 형식은 Firestore 웹 콘솔의 UI일 뿐, 실제 데이터는 Timestamp 객체임[4].

이 형식은 Firestore의 모든 Timestamp 필드(createdAt, updatedAt 등)에 동일하게 적용됩니다.",0,0,0
9,Firefox 58 환경에서 Gmail의 AMP 렌더링 기능이 호환되나요?,"네, Firefox 58 환경에서는 Gmail의 AMP 렌더링 기능이 호환됩니다. 문서에 따르면 Firefox 58이 Gmail의 지원되는 최소 버전이기 때문에 AMP 렌더링이 정상적으로 동작합니다.","Firefox 58에서는 Gmail의 AMP 렌더링 기능이 **지원됩니다**. Google 공식 문서에 따르면, Firefox의 최소 지원 버전이 58이며, 이 버전부터 Gmail의 AMP 이메일 렌더링이 가능하다고 명시되어 있습니다[1]. 

즉, Firefox 58 환경에서는 AMP 이메일이 정상적으로 렌더링되며, 호환되지 않는 브라우저에서는 AMP 대신 HTML 이메일이 표시되는 것과 구분됩니다. 다만, AMP 렌더링을 위해서는 브라우저에서 JavaScript와 쿠키가 활성화되어 있어야 하며, 최신 보안 업데이트가 적용된 상태가 권장됩니다[2].",95,95,90
10,Gmail 자가 테스트를 할 때 DKIM 또는 SPF 인증이 필요해?,"네, Gmail 자가 테스트를 할 때 DKIM 또는 SPF 인증이 여전히 필요합니다.","Gmail 자가 테스트 시에도 **DKIM 또는 SPF 인증 설정이 필요하다**. 특히, Gmail과 같은 메일 서비스는 SPF와 DKIM을 통해 발신 도메인의 신뢰성을 검증하며, 이를 통해 스팸이나 피싱으로 분류되는 것을 방지한다[2][5].

- **SPF**는 발신 서버가 해당 도메인에서 메일을 보낼 권한이 있는지를 DNS 레코드로 확인하는 방식이다.
- **DKIM**은 메일 내용이 전송 중 변경되지 않았음을 암호화 서명으로 증명한다.

Google Workspace 환경에서는 SPF와 DKIM 모두 설정하는 것이 권장되며, 특히 대량 메일 발송 시 두 인증 모두 필수적이다[2][3]. DKIM 설정은 도메인 DNS에 공개키 레코드를 추가하고, Google 관리 콘솔에서 DKIM 서명을 활성화하는 절차를 거친다[1][5].

자가 테스트용으로 자신에게 메일을 보낼 때도 DKIM 서명이 제대로 작동하는지 메일 헤더의 Authentication-Results에서 확인할 수 있다[5]. 따라서 테스트 단계에서도 SPF와 DKIM 설정이 되어 있어야 정확한 인증 결과를 확인할 수 있다.

요약하면, Gmail 자가 테스트를 하더라도 SPF와 DKIM 인증 설정은 필수이며, 이를 통해 메일이 정상적으로 인증되고 스팸으로 분류되지 않는지 검증할 수 있다.",90,95,95
11,"HTML 헤더에 스크립트 태그를 넣을 수 없을 때, 이메일 본문에 코드를 삽입하는 방법은?","HTML 헤더에 스크립트 태그를 넣을 수 없는 경우, 이메일 본문에 스크립트 태그의 일부 또는 전체를 삽입할 수 있습니다. 예를 들어, 거래 정보를 처리하는 시스템 부분에서 전체 스크립트 태그 또는 거래 <script>{""@type"": ""DiscountOffer"", …}</script>가 포함된 부분을 본문에 삽입하면 됩니다. 또한, 마이크로데이터(microdata) 방식을 사용하여 <div itemscope itemtype=""http://schema.org/DiscountOffer"">와 같이 HTML의 어느 곳에나 삽입할 수도 있습니다.","## 이메일 본문에 코드 삽입: HTML 헤더에 스크립트 태그가 불가할 때

이메일 클라이언트(예: Gmail, Outlook, 네이버 등)는 보안상의 이유로 HTML 이메일 본문에 `<script>` 태그를 허용하지 않습니다. 즉, 이메일 본문에 JavaScript를 직접 삽입하거나 실행하는 것은 불가능합니다. 이는 스팸 방지, 악성 코드 차단, 사용자 보호를 위한 표준적인 정책입니다.

## 대체 방법

**HTML 본문에 코드(예: HTML, CSS, 인라인 이미지 등) 삽입**

- **HTML 태그 직접 삽입**: 이메일 본문에 `<h1>`, `<p>`, `<img>`, `<a>` 등 일반적인 HTML 태그는 대부분의 이메일 클라이언트에서 지원됩니다. 예를 들어, `<h1>제목</h1><p>내용</p>`과 같이 작성하면 이메일 본문에 서식이 적용된 텍스트로 표시됩니다[1][4].
- **이미지 삽입**: `<img>` 태그를 사용해 base64 인코딩 이미지나 외부 이미지 URL을 삽입할 수 있습니다. 예: `<img src=""data:image/jpeg;base64,/9j..."">` 또는 `<img src=""https://example.com/image.jpg"">`[1].
- **CSS 인라인 스타일**: `<style>` 태그는 일부 클라이언트에서 제한될 수 있으므로, 주로 인라인 스타일(`style=""...""`)로 서식을 적용합니다.
- **코드 조각(스니펫) 활용**: Marketo 등 이메일 마케팅 플랫폼에서는 HTML 코드 조각(스니펫)을 재사용할 수 있도록 지원합니다. 이는 HTML 본문에 삽입되는 방식이며, `<script>`는 포함할 수 없습니다[2].

## 실제 예시 (C# 기준)

```csharp
string htmlContent = ""<html><body><h1>Welcome!</h1><p>This is a sample email with HTML.</p><img src='data:image/jpeg;base64,/9j...'></body></html>"";
message.HtmlBody = htmlContent;
```
이렇게 하면 이메일 본문에 HTML 서식과 이미지가 삽입됩니다[1].

## 주의사항

- **JavaScript 불가**: `<script>` 태그는 이메일 본문에 삽입해도 실행되지 않으며, 대부분의 클라이언트에서 차단됩니다.
- **호환성**: 모든 이메일 클라이언트가 동일한 HTML/CSS를 지원하지는 않으므로, 반응형 이메일 디자인을 위해 테스트가 필요합니다.
- **네이버 등 일부 서비스**: HTML 편집기를 제공해 본문에 HTML 태그를 직접 삽입할 수 있지만, 여전히 `<script>`는 지원하지 않습니다[5].

## 결론

이메일 본문에 코드를 삽입하려면 **HTML 태그와 인라인 스타일, 이미지 태그** 등을 사용해야 하며, JavaScript는 어떤 방법으로도 삽입할 수 없습니다. 이메일 마케팅이나 자동화 솔루션에서 코드 조각(스니펫)을 활용해 HTML 본문을 동적으로 구성할 수는 있지만, 이 역시 `<script>`는 포함할 수 없습니다[1][2].  
이메일 본문에 삽입할 수 있는 코드는 오직 **표현을 위한 HTML/CSS**에 한정됩니다.",70,60,55
12,OAuth에서 승인 사용자 인증 정보 만드는 방법 순서대로 알려주세요.,"OAuth에서 승인 사용자 인증 정보를 만드는 방법은 다음과 같습니다. 먼저, '클라이언트 만들기'를 클릭합니다. 다음으로, 'TV 및 입력 제한 기기 애플리케이션 유형'을 선택합니다. 마지막으로, OAuth 2.0 클라이언트의 이름을 지정하고 '만들기'를 클릭하면 완료됩니다.","OAuth에서 승인 사용자 인증 정보를 만드는 방법은 다음 순서대로 진행합니다.

1. **Google Cloud 콘솔 접속 및 프로젝트 선택**  
   Google Cloud 콘솔에 로그인 후, OAuth 인증을 적용할 프로젝트를 선택하거나 새 프로젝트를 만듭니다[3][5].

2. **OAuth 동의 화면 구성**  
   OAuth 클라이언트 ID를 만들기 전에 사용자에게 표시할 동의 화면을 설정합니다. 이 화면에는 애플리케이션 이름, 지원 이메일, 권한 범위 등이 포함됩니다[3].

3. **사용자 인증 정보 페이지로 이동**  
   왼쪽 메뉴에서 **[사용자 인증 정보]**를 선택한 후, **[사용자 인증 정보 만들기]** 버튼을 클릭합니다[1][2][3].

4. **OAuth 클라이언트 ID 생성 선택**  
   인증 정보 만들기 옵션 중에서 **OAuth 클라이언트 ID**를 선택합니다[1][2][3].

5. **애플리케이션 유형 선택**  
   애플리케이션 유형을 선택합니다. 보통 웹 애플리케이션을 선택하며, 데스크톱 앱, 모바일 앱 등도 선택 가능[1][3][5].

6. **OAuth 클라이언트 설정 입력**  
   - **애플리케이션 이름** 입력  
   - **승인된 자바스크립트 원본**(예: https://localhost:3000) 입력  
   - **승인된 리디렉션 URI**(예: http://localhost:3000/auth/google) 입력  
   이 URL들은 OAuth 인증 후 리디렉션될 주소로, 보안상 정확히 맞춰야 합니다[1][3].

7. **클라이언트 ID 생성 및 저장**  
   설정을 완료하고 **만들기** 버튼을 클릭하면 OAuth 클라이언트 ID와 클라이언트 비밀번호가 생성됩니다. 이 정보는 JSON 파일로 다운로드하여 안전하게 보관합니다[1][3][5].

8. **OAuth 클라이언트 정보 활용**  
   생성된 클라이언트 ID와 비밀번호를 애플리케이션에 적용하여 OAuth 인증 흐름을 구현합니다[4][5].

요약하면, Google Cloud 콘솔에서 프로젝트를 선택 → OAuth 동의 화면 구성 → 사용자 인증 정보 만들기 → OAuth 클라이언트 ID 선택 → 애플리케이션 유형 및 승인 URL 입력 → 클라이언트 ID 생성 및 저장 순서로 진행합니다[1][3][5].",70,60,50
13,Google의 계정 간 보안 서비스를 사용하는데 디코딩된 보안 이벤트 토큰의 events 클레임에는 어떤 정보가 포함되어 있나요? 그리고 디코딩된 보안 이벤트 토큰의 예시도 알려주세요.,"디코딩된 보안 이벤트 토큰의 events 클레임에는 토큰이 나타내는 보안 이벤트에 관한 정보가 포함됩니다. 이 클레임은 이벤트 유형 식별자에서 이 이벤트와 관련된 사용자를 지정하는 subject 클레임으로, 그리고 사용 가능한 이벤트에 관한 추가 세부정보로의 매핑입니다. 예를 들어, 아래와 같은 디코딩된 보안 이벤트 토큰 예시가 있습니다:

{
  ""iss"": ""https://accounts.google.com/"",
  ""aud"": ""123456789-abcedfgh.apps.googleusercontent.com"",
  ""iat"": 1508184845,
  ""jti"": ""756E69717565206964656E746966696572"",
  ""events"": {
    ""https://schemas.openid.net/secevent/risc/event-type/account-disabled"": {
      ""subject"": {
        ""subject_type"": ""iss-sub"",
        ""iss"": ""https://accounts.google.com/"",
        ""sub"": ""7375626A656374""
      },
      ""reason"": ""hijacking""
    }
  }
}","## Google 계정 간 보안 서비스의 보안 이벤트 토큰 events 클레임 정보

Google의 **계정 간 보안**(Cross-Account Security, RISC) 서비스는 Google 계정에서 발생한 의심스러운 보안 이벤트(예: 비밀번호 변경, 계정 복구, 의심스러운 로그인 등)를 타사 앱이나 서비스에 실시간으로 알릴 수 있도록 설계되었습니다[1][2].  
이 알림은 **보안 이벤트 토큰**(Security Event Token, SET)이라는 JWT(JSON Web Token) 형태로 전달되며, 이 토큰의 **events** 클레임에는 실제로 어떤 보안 이벤트가 발생했는지에 대한 구체적인 정보가 포함됩니다[1].

**events 클레임에 포함되는 주요 정보**  
events 클레임은 JSON 객체로, 각 이벤트 유형별로 고유한 필드와 값을 가집니다. 일반적으로 다음과 같은 정보가 포함될 수 있습니다.

- **이벤트 유형**(event_type): 예를 들어, account_disabled, account_enabled, credential_change, recovery_activated 등 Google에서 정의한 이벤트 유형 코드[1].
- **이벤트 발생 시각**(timestamp): 이벤트가 발생한 시간(ISO 8601 형식).
- **이벤트와 관련된 사용자 식별자**(subject): 해당 이벤트가 발생한 Google 계정의 식별자(일반적으로 sub 클레임과 동일).
- **이벤트별 추가 데이터**: 이벤트 유형에 따라 추가적인 메타데이터가 포함될 수 있습니다. 예를 들어, credential_change 이벤트라면 어떤 자격증명(비밀번호, 2단계 인증 등)이 변경되었는지에 대한 정보가 포함될 수 있음.

이 정보를 바탕으로 타사 서비스는 사용자 계정의 보안 상태를 실시간으로 파악하고, 필요시 추가적인 보안 조치(예: 세션 종료, 재인증 요청 등)를 취할 수 있습니다[1][2].

## 디코딩된 보안 이벤트 토큰 예시

아래는 **가상의** 디코딩된 보안 이벤트 토큰 예시입니다. 실제 토큰 구조와 필드명은 Google 공식 문서를 참고해야 하며, 여기서는 이해를 돕기 위해 일반적인 JWT 구조와 events 클레임의 예시를 제시합니다.

```json
{
  ""iss"": ""https://accounts.google.com"",
  ""aud"": ""your-client-id"",
  ""iat"": 1634567890,
  ""exp"": 1634568490,
  ""jti"": ""a1b2c3d4e5f6g7h8"",
  ""events"": {
    ""https://schemas.openid.net/secevent/risc/event-type/credential-change"": {
      ""subject"": {
        ""subject_type"": ""email"",
        ""email"": ""user@example.com""
      },
      ""timestamp"": 1634567890,
      ""credential_type"": ""password""
    }
  }
}
```

- **iss**: 토큰 발행자(Google)
- **aud**: 토큰 수신자(클라이언트 ID)
- **iat/exp**: 토큰 발행 및 만료 시간
- **jti**: 토큰 고유 식별자
- **events**: 실제 보안 이벤트 정보. 여기서는 credential-change(자격증명 변경) 이벤트가 발생했으며, 변경된 자격증명은 비밀번호임을 알 수 있음

이 예시에서 events 클레임은 단일 이벤트만 포함하고 있지만, 여러 이벤트가 동시에 발생한 경우 events 객체에 여러 이벤트가 배열 형태로 포함될 수 있습니다.

## 참고 사항

- **실제 토큰 구조와 필드명은 Google의 최신 문서를 반드시 확인해야 하며, 위 예시는 이해를 위한 참고용입니다**[1].
- **토큰은 반드시 서명 검증 후 디코딩해야 하며, 악의적인 토큰 주입을 방지하기 위해 aud(대상자) 클레임도 반드시 검증해야 합니다**[1].
- **이벤트 유형과 추가 데이터 필드는 Google이 공식적으로 제공하는 스키마를 따라야 하며, 서비스별로 다를 수 있습니다**.

Google의 계정 간 보안 서비스를 구현할 때는 공식 개발자 문서를 꼭 참고하시기 바랍니다[1].",70,75,70
14,People API의 RequestMask 필드에 무엇을 입력해야 하나요?,지원 중단되었습니다. 대신 personFields를 사용해 주세요.,"People API의 RequestMask 필드는 **더 이상 사용되지 않으며(deprecated), 대신 personFields 쿼리 매개변수를 사용해야 합니다**. RequestMask는 응답에 포함할 사람 필드의 하위 집합을 제한하는 역할을 했으나, 현재는 personFields에 쉼표로 구분된 필드 이름을 지정하는 방식으로 대체되었습니다[1][2].

즉, RequestMask 필드에 무엇을 입력해야 하냐는 질문에 대한 답은:

- **RequestMask 대신 personFields에 원하는 사람 필드를 쉼표로 구분하여 입력하세요.**
- 예를 들어, `personFields=names,emailAddresses,photos` 와 같이 입력합니다.
- personFields는 필수이며, 지정하지 않으면 400 오류가 발생합니다[1].

RequestMask의 includeField 속성은 과거에 사용되었으며, ""person.""으로 시작하는 필드 경로를 쉼표로 나열하는 형식이었으나 현재는 권장되지 않습니다[2][3].

요약하면, 최신 Google People API 사용 시에는 RequestMask 대신 **personFields** 쿼리 매개변수를 사용하여 반환받고자 하는 필드를 지정해야 합니다.",95,95,95
15,People API에 요청을 보내는 Python 스크립트를 어떻게 실행하고 구성해야 하는지 알려줘,"People API에 요청을 보내는 Python 스크립트를 실행하고 구성하려면 다음 단계를 따르면 됩니다. 먼저, Python용 Google 클라이언트 라이브러리를 설치해야 합니다. 그런 다음 작업 디렉터리에 quickstart.py라는 파일을 만들고, 제공된 샘플 코드를 해당 파일에 포함시킵니다. 이후 작업 디렉터리에서 'python3 quickstart.py' 명령어로 스크립트를 실행하면 됩니다. 처음 실행 시에는 Google 계정으로 로그인하고 액세스 권한을 승인해야 하며, 승인 정보는 파일 시스템에 저장되어 이후에는 승인 메시지가 다시 표시되지 않습니다.","People API에 요청을 보내는 Python 스크립트를 실행하고 구성하려면 다음 단계를 따르면 됩니다.

1. **Google Cloud 프로젝트 및 People API 활성화**  
   - Google Cloud Console에서 프로젝트를 생성하거나 선택합니다.  
   - People API를 활성화합니다.  
   - OAuth 2.0 클라이언트 ID를 생성하여 인증 정보를 준비합니다(사용자 인증이 필요한 경우).  
   이 과정은 Google People API를 사용하기 위한 필수 준비 단계입니다[5].

2. **필요한 라이브러리 설치**  
   - Google API Python 클라이언트 라이브러리 설치:  
     ```bash
     pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
     ```  
   - HTTP 요청을 직접 다루고 싶다면 `requests` 라이브러리도 설치할 수 있습니다:  
     ```bash
     pip install requests
     ```  
   (보통 Google API 클라이언트 라이브러리를 권장합니다)[1][2][4].

3. **인증 및 서비스 객체 생성**  
   OAuth 2.0 인증을 통해 사용자 권한을 얻고, People API 서비스 객체를 생성합니다. 예를 들어, OAuth 인증을 위한 코드 샘플은 Google 공식 문서나 관련 튜토리얼에서 확인할 수 있습니다. 인증 후 다음과 같이 서비스 객체를 만듭니다:

   ```python
   from google.oauth2.credentials import Credentials
   from googleapiclient.discovery import build

   creds = Credentials(token='YOUR_ACCESS_TOKEN')  # OAuth 인증 후 토큰 사용
   people_service = build('people', 'v1', credentials=creds)
   ```

4. **People API 호출 예시: 사용자 연락처 목록 조회**  
   다음은 인증된 서비스 객체를 사용해 내 연락처 목록을 가져오는 간단한 예시입니다:

   ```python
   results = people_service.people().connections().list(
       resourceName='people/me',
       personFields='names,emailAddresses'
   ).execute()

   connections = results.get('connections', [])
   for person in connections:
       names = person.get('names', [])
       if names:
           print('Name:', names[0].get('displayName'))
   ```
   이 코드는 내 Google 주소록에서 이름과 이메일 주소를 가져옵니다[3][5].

5. **스크립트 실행**  
   위 코드를 `people_api_example.py` 같은 파일에 저장한 후, 터미널에서 다음과 같이 실행합니다:

   ```bash
   python people_api_example.py
   ```

6. **요약**  
   - Google Cloud에서 People API 활성화 및 OAuth 인증 설정  
   - Python용 Google API 클라이언트 라이브러리 설치  
   - OAuth 인증 후 서비스 객체 생성  
   - `people().connections().list()` 메서드로 연락처 데이터 요청  
   - Python 스크립트로 실행하여 결과 확인

이 과정은 Google 공식 문서와 여러 튜토리얼에서 권장하는 표준적인 방법입니다[1][3][5]. 만약 인증 없이 공개 API를 호출하는 경우라면 `requests` 라이브러리를 사용해 HTTP GET/POST 요청을 직접 보내는 방법도 있습니다[2][4]. 그러나 People API는 사용자 데이터 접근이므로 OAuth 인증이 필수입니다.",70,80,75
16,Google Sheets의 SERIAL_NUMBER 형식으로 1900년 2월 1일 오후 5시의 경우 어떻게 계산해? 일련번호는 어떤식으로 계산하는 거야?,"Google Sheets의 SERIAL_NUMBER 형식에서 1900년 2월 1일 오후 5시는 33.708333...으로 계산됩니다. 일련번호는 1899년 12월 30일을 기준으로 경과된 일수(정수 부분)와, 시간은 하루의 비율(소수 부분)로 계산합니다. 예를 들어, 1900년 2월 1일은 1899년 12월 30일로부터 33일이 경과했고, 오후 5시는 하루(24시간) 중 17/24이므로 0.708333...이 더해집니다. 따라서 일련번호는 33 + 17/24 = 33.708333...이 됩니다.","Google Sheets에서 날짜와 시간은 **1900년 1월 1일 0시 0분 0초를 기준으로 한 일련번호(Serial Number)**로 계산됩니다. 이 일련번호는 정수 부분이 날짜를, 소수 부분이 시간을 나타냅니다.

- 1900년 1월 1일 0시는 일련번호 1입니다.
- 1900년 1월 2일 0시는 일련번호 2입니다.
- 시간은 하루(1) 단위를 24시간으로 나눈 소수로 표현합니다. 예를 들어, 오후 5시는 17/24 = 0.708333... 입니다.

따라서, **1900년 2월 1일 오후 5시**의 일련번호는 다음과 같이 계산합니다.

1. 1900년 1월 1일부터 1900년 2월 1일까지 날짜 수를 구합니다.  
   - 1900년 1월 1일이 1이므로, 1900년 2월 1일은 32번째 날입니다 (1월 31일 + 1일).  
   즉, 날짜 정수 부분은 32입니다.

2. 오후 5시는 하루의 17/24이므로 소수 부분은 약 0.708333입니다.

3. 따라서 일련번호는  
   \( 32 + \frac{17}{24} = 32.708333 \) 입니다.

Google Sheets에서 직접 계산하려면 다음 수식을 사용할 수 있습니다.

```excel
=DATE(1900, 2, 1) + TIME(17, 0, 0)
```

이 수식은 1900년 2월 1일 오후 5시의 일련번호를 반환합니다. 결과는 약 32.708333이 됩니다[1][3].

요약하면, Google Sheets의 날짜 일련번호는 **1900년 1월 1일 0시를 1로 시작하는 정수 + 시간의 24분의 1 단위 소수**로 계산됩니다.",70,70,70
17,YouTube Data API를 사용하는 프로젝트의 기본 할당량은 얼마인가요?,"YouTube Data API를 사용하는 프로젝트의 기본 할당량은 일일 10,000단위입니다. 이는 대부분의 API 사용자에게 충분한 양입니다.","YouTube Data API를 사용하는 프로젝트의 기본 할당량은 **일일 10,000 단위**입니다[1][6]. 이 할당량은 대부분의 API 사용자에게 충분한 양으로 간주되며, 각 API 요청은 할당량 비용을 소모합니다[6]. 할당량은 태평양 표준시 자정에 재설정됩니다[1][6].",95,100,90
